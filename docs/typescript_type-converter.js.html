

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Super docs typescript/type-converter.js</title>
  
    <link rel="icon" type="image/svg+xml" href="images/favicon.svg">
    <link rel="shortcut icon" type="" href="./images/favicon.png"/>
    <link rel="icon" type="" href="./images/favicon.png"/>
  
  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
 
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css2?family=Muli&family=Libre+Barcode+39+Text&family=Anton&family=Fira+Mono&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
   <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/4.18.3/swagger-ui.css" />
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
  <script async defer src="https://buttons.github.io/buttons.js"></script>
  
</head>



<body class="layout">
    <script src="scripts/img-alt-caption.js"></script>
    <script src="scripts/jsdoc-mermaid.js"></script>
    
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
             
                <a class="image" href="index.html">
                    <img src="images/logo.png" alt="logo">
                </a>
            
             
                <a href="index.html">
                    <h1 class="navbar-item">Super Docs</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                    <a
                        href="changelog.html"
                        class="link"
                    >
                      LOG
                    </a>
                
                
                    <a
                        href="swagger.html"
                        class="link"
                    >
                       API
                    </a>
                
                
                <div class="dropdown is-hoverable is-right">
                    <a class="dropdown-trigger link">
                        Tutorials
                        <i class="fas fa-chevron-down fa-xs"></i>
                    </a>
                    <div class="dropdown-menu">
                        <div class="dropdown-content">
                        
                            <a class="dropdown-item" href="tutorial-my-awesome-tutorial.html">
                                01. My Awesome Tutorial
                            </a>
                        
                        </div>
                    </div>
                </div>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2> <h2><a href="changelog.html">LOG</a></h2>  <h2><a href="swagger.html">API</a></h2> <div class="category"><h3>Classes</h3><ul><li><a href="AbstractClass.html">AbstractClass</a></li><li><a href="ClassName.html">ClassName</a></li><li><a href="ComponentRenderer.html">ComponentRenderer</a></li><li><a href="reactComponents.html">reactComponents</a></li><li><a href="SomeClass.html">SomeClass</a></li><li><a href="ValidationError_ValidationError.html">ValidationError</a></li></ul><h3>Interfaces</h3><ul><li><a href="PropertyJSON.html">PropertyJSON</a></li></ul><h3>Global</h3><ul><li><a href="global.html#add">add</a></li><li><a href="global.html#addCopyButton">addCopyButton</a></li><li><a href="global.html#addImageCaption">addImageCaption</a></li><li><a href="global.html#addLineNumbers">addLineNumbers</a></li><li><a href="global.html#addMermaidCaption">addMermaidCaption</a></li><li><a href="global.html#buildGroupNav">buildGroupNav</a></li><li><a href="global.html#buildNav">buildNav</a></li><li><a href="global.html#checkType">checkType</a></li><li><a href="global.html#convertMembers">convertMembers</a></li><li><a href="global.html#convertParams">convertParams</a></li><li><a href="global.html#DefaultWrapper">DefaultWrapper</a></li><li><a href="global.html#Documented">Documented</a></li><li><a href="global.html#fillMethodComment">fillMethodComment</a></li><li><a href="global.html#getCommentAsString">getCommentAsString</a></li><li><a href="global.html#getName">getName</a></li><li><a href="global.html#getTypeName">getTypeName</a></li><li><a href="global.html#linktoExternal">linktoExternal</a></li><li><a href="global.html#linktoTutorial">linktoTutorial</a></li><li><a href="global.html#myAdd">myAdd</a></li><li><a href="global.html#publish">publish</a></li><li><a href="global.html#renderComponent">renderComponent</a></li><li><a href="global.html#renderMermaidLangs">renderMermaidLangs</a></li><li><a href="global.html#search">search</a></li><li><a href="global.html#sidebarIsVisible">sidebarIsVisible</a></li><li><a href="global.html#swaggerDefinition">swaggerDefinition</a></li><li><a href="global.html#Test">Test</a></li></ul></div><div class="category"><h2>Application services</h2><h3>Classes</h3><ul><li><a href="MatrixBridge.html">MatrixBridge</a></li></ul></div><div class="category"><h2>Errors</h2><h3>Classes</h3><ul><li><a href="ValidationError.html">ValidationError</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>typescript/type-converter.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const path = require('path')
const ts = require('typescript')

const appendComment = (commentBlock, toAppend) => {
  return commentBlock.replace(/[\n,\s]*\*\//, toAppend.split('\n').map(line => `\n * ${line}`) + '\n */')
}

/**
 * Get type from a node
 * @param {ts.TypeNode} type which should be parsed to string
 * @param {string} src      source for an entire parsed file
 * @returns {string}    node type
 */
const getTypeName = (type, src) => {
  if(!type) { return ''}
  if (type.typeName &amp;&amp; type.typeName.escapedText) {
    const typeName = type.typeName.escapedText
    if(type.typeArguments &amp;&amp; type.typeArguments.length) {
      const args = type.typeArguments.map(subType => getTypeName(subType, src)).join(', ')
      return `${typeName}&lt;${args}>`
    } else {
      return typeName
    }
  }
  if(ts.isFunctionTypeNode(type) || ts.isFunctionLike(type)) {
    // it replaces ():void => {} (and other) to simple function
    return 'function'
  }
  if (ts.isArrayTypeNode(type)) {
    return 'Array'
  }
  if (type.types) {
    return type.types.map(subType => getTypeName(subType, src)).join(' | ')
  }
  if (type.members &amp;&amp; type.members.length) {
    return 'object'
  }
  return src.substring(type.pos, type.end).trim()
}

/**
 * Fetches name from a node.
 */
const getName = (node, src) => {
  let name = node.name?.escapedText
  || node.parameters &amp;&amp; src.substring(node.parameters.pos, node.parameters.end)
  
  // changing type [key: string] to {...} - otherwise it wont be parsed by @jsdoc
  if (name === 'key: string') { return '{...}' }
  return name
}

/** 
 * Check type of node (dev only)
 * @param {node} node
 * @return {void} Console log predicted types
 */
function checkType(node) {
  console.group(node.name?.escapedText);
  const predictedTypes = Object.keys(ts).reduce((acc, key) => {
    if (typeof ts[key] !== "function" &amp;&amp; !key.startsWith("is")) {
      return acc;
    }
    try {
      if (ts[key](node) === true) {
        acc.push(key);
      }
    } catch (error) {
      return acc;
    }
    return acc;
  }, []);
  console.log(predictedTypes);
  console.groupEnd();
}
  

/**
 * Fill missing method declaration
 * 
 * @param {string} comment
 * @param member
 * @param {string} src
 * @return {string}
 */
const fillMethodComment = (comment, member, src) => {
  if (!comment.includes('@method')) {
    comment = appendComment(comment, '@method')
  }
  if (!comment.includes('@param')) {
    comment = convertParams(comment, member, src)
  }
  if (member.type &amp;&amp; ts.isArrayTypeNode(member.type)) {
    comment = convertMembers(comment, member.type, src)
  }
  if (member.type &amp;&amp; !comment.includes('@return')) {
    const returnType = getTypeName(member.type, src)
    comment = appendComment(comment, `@return {${returnType}}`)
  }
  return comment
}

/**
 * converts function parameters to @params
 *
 * @param {string} [jsDoc]  existing jsdoc text where all @param comments should be appended
 * @param {ts.FunctionDeclaration} wrapper ts node which has to be parsed
 * @param {string} src      source for an entire parsed file (we are fetching substrings from it)
 * @param {string} parentName     name of a parent element - NOT IMPLEMENTED YET
 * @returns {string} modified jsDoc comment with appended @param tags
 * 
 */
const convertParams = (jsDoc = '', node, src) => {
  const parameters = node.type?.parameters || node.parameters
  if(!parameters) { return }
  parameters.forEach(parameter => {
    let name = getName(parameter, src)
    let comment = getCommentAsString(parameter, src)
    if (parameter.questionToken) {
      name = ['[', name, ']'].join('')
    }
    let type = getTypeName(parameter.type, src)
    jsDoc = appendComment(jsDoc, `@param {${type}} ${name}   ${comment}`)
  })
  return jsDoc
}

/**
 * Convert type properties to @property
 * @param {string} [jsDoc]  existing jsdoc text where all @param comments should be appended
 * @param {ts.TypeNode} wrapper ts node which has to be parsed
 * @param {string} src      source for an entire parsed file (we are fetching substrings from it)
 * @param {string} parentName     name of a parent element
 * @returns {string} modified jsDoc comment with appended @param tags
 */
let convertMembers = (jsDoc = '', type, src, parentName = null) => {
  // type could be an array of types like: `{sth: 1} | string` - so we parse
  // each type separately
  const typesToCheck = [type]
  if (type.types &amp;&amp; type.types.length) {
    typesToCheck.push(...type.types)
  }
  typesToCheck.forEach(type => {
    // Handling array defined like this: {element1: 'something'}[]
    if(ts.isArrayTypeNode(type) &amp;&amp; type.elementType) {
      jsDoc = convertMembers(jsDoc, type.elementType, src, parentName ? parentName + '[]' : '[]')
    }

    // Handling Array&lt;{element1: 'something'}>
    if (type.typeName &amp;&amp; type.typeName.escapedText === 'Array') {
      if(type.typeArguments &amp;&amp; type.typeArguments.length) {
        type.typeArguments.forEach(subType => {

          jsDoc = convertMembers(jsDoc, subType, src, parentName
            ? parentName + '[]'
            : '' // when there is no parent - jsdoc cannot parse [].name
          )
        })
      }
    }
    // Handling {property1: "value"}
    (type.members || []).filter(m => ts.isTypeElement(m)).forEach(member => {
      let name = getName(member, src)
      let comment = getCommentAsString(member, src)
      const members = member.type.members || []
      let typeName = members.length ? 'object' : getTypeName(member.type, src)
      if (parentName) {
        name = [parentName, name].join('.')
      }
      // optional
      const nameToPlace = member.questionToken ? `[${name}]` : name
      jsDoc = appendComment(jsDoc, `@property {${typeName}} ${nameToPlace}   ${comment}`)
      jsDoc = convertMembers(jsDoc, member.type, src, name)
    })
  })
  return jsDoc
}

/** 
 * Extract comment from member jsDoc as string
 * @param member
 * @param {string} src
 * @returns {string} 
 */
function getCommentAsString(member, src) {
  if (member.jsDoc &amp;&amp; member.jsDoc[0] &amp;&amp; member.jsDoc[0].comment) {
    const comment = member.jsDoc[0].comment;
    if (Array.isArray(comment)) {
      return comment
        .map((c) => c.text.length ? c.text : src.substring(c.pos, c.end))
        .join('');
    }
    return member.jsDoc[0].comment;
  }
  return '';
}

/**
 * Main function which converts types
 * 
 * @param {string} src           typescript code to convert to jsdoc comments
 * @param {string} [filename]    filename which is required by typescript parser
 * @return {string}              @jsdoc comments generated from given typescript code
 */
module.exports = function typeConverter(src, filename = 'test.ts') {
  let ast = ts.createSourceFile(
    path.basename(filename),
    src,
    ts.ScriptTarget.Latest,
    false,
    ts.ScriptKind.TS
  )
  
  // iterate through all the statements in global scope
  // we are looking for `interface xxxx` and `type zzz`
  return ast.statements.map(statement => {
    let jsDocNode = statement.jsDoc &amp;&amp; statement.jsDoc[0]
    // Parse only statements with jsdoc comments.
    if (jsDocNode) {
      let comment = src.substring(jsDocNode.pos, jsDocNode.end)
      const name = getName(statement, src)
      if (ts.isFunctionDeclaration(statement)) {
          return fillMethodComment(comment, statement, src);
      }
      if (ts.isTypeAliasDeclaration(statement)) {
        if (ts.isFunctionTypeNode(statement.type)) {
          comment = appendComment(comment, `@typedef {function} ${name}`)
          return convertParams(comment, statement, src)
        }
        if (ts.isTypeLiteralNode(statement.type)) {
          comment = appendComment(comment, `@typedef {object} ${name}`)
          return convertMembers(comment, statement.type, src)
        }
        if (ts.isIntersectionTypeNode(statement.type)) {
          comment = appendComment(comment, `@typedef {object} ${name}`)
          return convertMembers(comment, statement.type, src)
        }
        if (ts.isUnionTypeNode(statement.type) || ts.isSimpleInlineableExpression(statement.type)) {
          let typeName = getTypeName(statement.type, src)
          comment = appendComment(comment, `@typedef {${typeName}} ${name}`)
          return convertMembers(comment, statement.type, src)
        }      
      }
      if (ts.isInterfaceDeclaration(statement)) {
        comment = appendComment(comment, `@interface ${name}`)

        statement.members.forEach(member => {
          if (!member.jsDoc) { return }
          let memberComment = src.substring(member.jsDoc[0].pos, member.jsDoc[0].end)
          let memberName = getName(member, src)
          memberComment = appendComment(memberComment, [
            `@name ${name}#${memberName}`
          ].join('\n'))
          if (member.questionToken) {
            memberComment = appendComment(memberComment, '@optional')
          }
          if (!member.type &amp;&amp; ts.isFunctionLike(member)) {
            let type = getTypeName(member, src)
            memberComment = appendComment(memberComment, `@type {${type}}`)
            memberComment = appendComment(memberComment, '@method')
          } else {
            memberComment = convertMembers(memberComment, member.type, src)
            let type = getTypeName(member.type, src)
            memberComment = appendComment(memberComment, `@type {${type}}`)
          }
          comment += '\n' + memberComment
        })
        return comment
      }
      if (ts.isClassDeclaration(statement)) {
        comment = ''
        const className = getName(statement, src)
        statement.members.forEach(member => {
          if (!member.jsDoc) { return }
          let memberComment = src.substring(member.jsDoc[0].pos, member.jsDoc[0].end)
          const modifiers = (member.modifiers || []).map(m => m.getText({text: src}))
          modifiers.forEach(modifier => {
            const allowedModifiers = ['async', 'abstract', 'private', 'public', 'protected']
            if (allowedModifiers.includes(modifier)) {
              memberComment = appendComment(memberComment, `@${modifier}`)
            }
          })
          if (member.type &amp;&amp; ts.isPropertyDeclaration(member)) {
            const type = getTypeName(member.type, src)
            memberComment = appendComment(memberComment, `@type {${type}}`)
          }
          if (ts.isFunctionLike(member)) {
            memberComment = fillMethodComment(memberComment, member, src)
          }
          if (ts.isConstructorDeclaration(member)) {
            memberComment = appendComment(memberComment, `@constructor`)
            memberComment += `\n${className}.prototype.${className}`
          } else {
            if (modifiers.find((m) => m === "static")) {
              memberComment += `\n${className}.${getName(member, src)}`
            } else {
              memberComment += `\n${className}.prototype.${getName(member, src)}`
            }
          }
          comment += "\n" + memberComment
        })
        return comment
      }
    }
    return ''
  }).join('\n')
}
</code></pre>
        </article>
    </section>




            </div>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>
<script src="scripts/codeHeader.js"></script>
<script src="scripts/tapMenueDropDown.js"> </script>

<script src="scripts/search.js"> </script>


</body>
</html>
